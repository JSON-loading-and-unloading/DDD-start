# 03 애그리거트

## 3.1 애그리거트

- 애그리거트는 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위해 상위 수준에서 모델을 조망할 수 있는 방법이다.
- 애그리거트는 관련된 객체를 하나의 군으로 묶어 준다. 수많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.
    - 모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 때문에, 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.
    - 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어든다.
- 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
    - 도메인 규칙에 따라 최초 주문 시점에 일부 객체를 만들 필요가 없는 경우도 있지만 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다.
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자식을 관리할 뿐 다른 애그리거트를 관리하지 않는다.
- 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다. 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
- 흔히 ‘A가 B를 갖는다’로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각하기 쉬우나, 항상 이런것은 아니다
    - EX) ‘상품’이 ‘상품 리뷰’를 가지고 있으나, ‘상품’과 ‘상품 리뷰’는 함께 생성되지도 않고, 함께 변경되지도 않는다.
- 도메인 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어든다.

## 3.2 애그리거트 루트

- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 된다. 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
    - EX) 주문 애그리거트에서 OrderLine을 변경하면 Order의 totalAmounts도 다시 계산해서 총 금액이 맞아야 한다.
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 애그리거트의 루트 엔티티이다.
    - 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.

### 도메인 규칙과 일관성

- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 된다. 이것은 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.
- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야 한다.
    - `set` 메서드를 `public`으로 구현하지 않아야 한다.
    - 밸류 타입은 불변으로 구현한다.
- 애그리거트 루트가 도메인 규칙을 올바르게만 구현하면 애그리거트 전체 일관성을 올바르게 유지할 수 있다.

### 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
- 애그리거트 루트가 구성 요소의 상태를 참조하는 것 뿐만 아니라 기능 실행을 위임하기도 한다.
- 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문에 패키지나 protected 범위를 사용하면 애그리커트 외부에서 상태 변경 기능을 실행하는 것을 방지할 수 있다.

### 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋다. 한 트랜잭션이 한 개 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것을 비교하면 성능에서 차이가 발생한다.
    - 한 개 테이블을 수정하면 트랜잭션 충돌을 막기 위해 잠그는 대상이 한 개 테이블의 한 행으로 한정되지만, 세 개의 테이블을 수정하면 잠금 대상이 더 많아진다.
    - 잠금 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 의미하고 이는 전체적인 성능을 떨어뜨린다.
- 동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생한 가능성이 더 높아지기 때문에 한 번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어지게 된다.
- 한 트랜잭선에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.
    - 한 애그리거트에서 다른 애그리거트를 수정하면 결과적으로 두 개의 애그리거트를 한 트랜잭션에서 수정하게 되므로, 애그리거트 내부에서 다른 애그리거트의 상태를 변경하는 기능을 실행하면 안 된다.
- 만약 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다.
- 도메인 이벤트를 사용하면 한 트랜잭션에서 동기나 비동기로 다른 애그리거트 상태를 변경하도록 구현할 수 있다.
- 다음 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
    - **팀 표준**: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스 기능을 한 트랜잭션으로 실행해야 하는 경우가 있다.
    - **기술 제약**: 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.
    - **UI 구현의 편리**: 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶은 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경해야 한다.

## 3.3 리포지터리 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
    - Order와 OrderLine을 물리적으로 각각 별도의 DB 테이블에 저장한다고 해서 Order와 OrderLine을 위한 리포지터리를 각각 만들지 않는다. Order가 애그리거트 루트고 OrderLine은 애그리거트에 속하는 구성요소이므로 Order를 위한 리포지터리만 존재한다.
- 새로운 애그리거트를 만들면 저장소에 애그리거트를 영속화하고 애그리거트를 사용하려면 저장소에서 애그리거트를 읽어야 하므로, 리포지터리는 보통 다음의 두 메서드를 기본으로 제공한다.
    - save : 애그리거트 저장
    - findById : ID로 애그리거트를 구함
- 이 두 메서드 외에 필요에 따라 다양한 조건으로 애그리거트를 검색하는 메서드나 애그리거트를 삭제하는 메서드를 추가할 수 있다.
- 어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다. JPA를 사용하면 데이터베이스 관계형 모델에 따라 객체 도메인 모델을 맞춰야 할 때도 있다.
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.
    - 애그리거트 루트를 저장할 때 애그리거트에 속한 모든 구성요소에 매핑된 테이블에 데이터를 저장해야 한다.
- 애그리거트를 조회할 때에는 완전한 애그리거트를 제공해야 한다.
    - EX) order 애그리거트는 OrderLine, Orderer 등 모든 구성요소를 포함하고 있어야 한다.
- RDBMS를 이용하면 트랜잭션을 이용해 애그리거트의 일관성 있는 변경을 저장소에 반영시킬 수 있다.
- Mongo DB를 사용하면 한 개 애그리거트를 한 개 문서에 저장함으로써 한 애그리거트의 변경을 손실 없이 저장소에 반영할 수 있다.

## 3.4 ID를 이용한 애그리거트 참조

- 애그리거트도 다른 애그리거트를 참조한다.
- 애그리거트 관리 주체는 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같다.
- 애그리거트 간 참조는 필드를 통해 쉽게 구현할 수 있다.
- 필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다.
    - ORM 기술 덕에 애그리거트 루트에 대한 참조를 쉽게 구현할 수 있고 필드를 이용한 애그리거트 참조를 사용하면 다른 애그리거트의 데이터릴 쉽게 조회할 수 있다.
- 하지만 필드를 이용한 애그리거트 참조는 다름 문제를 야기할 수 있다.
    - 편한 탐색 오용
        - 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다.
        - 이로 인해 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 하는데 구현의 편리함 때문에 다른 애그리거트를 수정하고자 하는 유혹에 빠지기 쉽다.
        - 한 애그리거트에서 다른 애그리거트 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.
    - 성능에 대한 고민
        - JPA를 사용한다면 조회 목적에 따라 지연로딩/즉시로딩을 고민해야 한다.
        - 다양한 경우의 수를 고려하여 연관 매핑과 JPQL/Criteria 쿼리 로딩 전략을 결정해야 한다.
    - 확장 어려움
        - 트래픽이 증가하면 부하 분산을 위해 하위 도메인별로 시스템을 분리하기 시작하게 되는데, 이때 서로 다른 DBMS를 사용할 때도 있다.
        - 이는 더 이상 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미한다.
- 이 세 가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.
- DB 테이블에서 외래키로 참조하는 것과 비슷하게 ID를 이용한 참조는 다른 애그리거트를 참조할 때 ID를 사용한다.
- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.
- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.
    - 이는 애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다. 또한 애그리거트 간의 의존을 제거하므로 응집도를 높여주는 효과도 있다.
    - 구현 복잡도도 낮아진다. 다른 애그리거트를 직접 참조하지 않으므로 애그리거트 간 참조를 지연 로딩으로 할지 즉시 로딩으로 할지 고민하지 않아도 된다. 참조하는 애그리거트가 필요하면  응용 서비스에서 ID를 이용해 로딩하면 된다.
    - 응용 서비스에서 필요한 애그리거트를 로딩하므로 애그리거트 수준에서 지연 로딩을 하는 것과 동일한 결과를 만든다.
- ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 근원적으로 방지할 수 있다. 외부 애그리거트를 직접 참조하지 않기 때문에 애초에 한 애그리거트에서 다른 애그리거트의 상태를 변경할 수 없는 것이다.
- 애그리거트별로 다른 구현 기술을 사용하는 것도 가능해진다.

### ID를 이용한 참조와 조회 성능

- 다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제 될 수 있다.
    - 주문 10개를 읽어오기 위한 1번의 쿼리와, 주문별로 각 상품을 읽어오기 위한 10번의 쿼리를 추가로 실행한다. → N+1 문제
    - 직접 참조를 했다면 조인을 통해 한 번에 가져올 수 있지만 ID 참조는 불가능하다.
- ID 참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 조회 전용 쿼리를 사용하면 된다.
- 애그리거트마다 서로 다른 저장소를 사용하면 한 번에 조회할 수 없기에 캐시를 적용하거나 조회 전용 저장소를 따로 구성한다.
    - 코드가 복잡해지는 단점이 있지만 시스템 처리량을 높일 수 있다.
    - 한 대 DB로 대응할 수 없는 트래픽이 발생하는 경우 캐시나 조회 전용 저장소는 필수로 선택해야 하는 기법이다.

## 3.5 애그리거트 간 집합 연관

- 애그리거트 간 1-N과 M-N 연관은 컬렉션을 이용한 연관이다.
- 조회의 관점에서 애그리거트 간 1-N 관계에서 1이 N을 갖는 것이 아닌 N이 1을 참조하는 식으로 구현해야 한다.
    - 1이 N을 가지도록 하면 DBMS와 연동해서 구현할 때 N이 수만 개 정도로 많다면 매번 모두 조회해야 하기에 성능에 심각한 문제를 일으킬 수 있다.
- M-N 연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다.
    - M-N 연관도 1-N 연관처럼 실제 요구사항을 고려하여 M-N 연관을 구현에 포함시킬지를 결정해야 한다.

## 3.6 애그리거트를 팩토리로 사용하기

```java
public class RegisteredProductService {

	public ProductId registerNewProduct(NewProductRequest req) {
		Store store = storeRepository.findStoreById(req.getStoreId());
		checkNull(store);
		if (store.isBlocked()) {
			throw new StoreBlockedException();
		}
		ProductId in = productRepository.nextId()
		Product product = new Product(id, store.getId(), ..);
		productRepository.save(product);
		return id;
	}
	...
}
```

- 위에 코드는 Product를 생성 가능한지 판단하는 코드와 Product를 생성하는 코드가 분리되어있다. 여기서 중요한 도메인 로직 처리가 응용 서비스에 노출되었다.
    - Store가 Product를 생성할 수 있는지를 판단하고 Product를 생성하는  것은 논리적으로 하나의 도메인 기능인데 이 도메인 기능을 응용 서비스에서 구현하고 있는 것이다.
- 이 도메인 기능을 넣기 위한 별도의 도메인 서비스나 팩토리 클래스를 만들 수도 있지만 이 기능을 Store 애그리커트에 구현할 수도 있다.
    
    ```java
    public class Store {
    	
    	public Product createProduct(ProductId newProductId,..) {
    		if (isBlocked()) throw new StoreBlockedException();
    		return new Product(newProductId, getId(),..);
    	}
    }
    ```
    
    - Store 애그리거트의 createProduct() 는 Product 애그리거트를 생성하는 팩토리 역할을 한다. 팩토리 역할을 하면서도 중요한 도메인 로직을 구현하고 있다. 응용 서비스는 팩토리 기능을 이용해 Product를 생성하면 된다.
    
    ```java
    public class RegisteredProductService {
    
    	public ProductId registerNewProduct(NewProductRequest req) {
    		Store store = findStoreById(req.getStoreId());
    		checkNull(store);
    		ProductId id = productRepository.nextId();
    		Product product = store.createProduct(id,..);
    		productRepository.save(product);
    		return id;
    	}
    }
    ```
    
    - 앞선 코드와 차이점은 응용 서비스에서 더 이상 Store의 상태를 확인하지 않는다는 것이다. Store가 Product를 생성할 수 있는지를 확인하는 도메인 로직은 Store에서 구현하고 있다.
    - 이제 Product 생성 가능 여부를 확인하는 도메인 로직을 변경해도 도메인 영역의 Store만 변경하면 되고 응용 서비스는 영향을 받지 않는다. 도메인의 응집도도 높아졌다.
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해 보자.