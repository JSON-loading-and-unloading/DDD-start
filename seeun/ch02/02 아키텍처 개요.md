# 02 아키텍처 개요

## 2.1 네 개의 영역

- ‘표현’, ‘응용’, ‘도메인’, ‘인프라스트럭처’는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역이다.

### 표현 영역(UI 영역)

- 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다.
    - EX) 웹 애플리케이션 표현 영역은 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고 응용 영역의 응답을 HTTP 응답으로 변환하여 전송한다.
- 표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수도 있고, REST API를 호출하는 외부 시스템일 수도 있다.

### 응용 영역

- 시스템이 사용자에게 제공해야 할 기능을 구현. 이를 위해 도메인 영역의 도메인 모델을 사용한다.
- 응용 영역은 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.

### 도메인 영역

- 도메인 모델(도메인의 핵심 로직)을 구현한다.

### 인프라스트럭처

- 구현 기술에 대한 것을 다룬다. 인프라스트럭처 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.
- 도메인 영역, 응용 영역, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않는다. 대신 인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.

## 2.2 계층 구조 아키텍처

- 보통 네 영역을 구성할 때 표현 영역과 응용 영역은 도메인 영역을 사용하고, 도메인 영역은 인프라스트럭처 영역을 사용한다.
    - 도메인의 복잡도에 따라 응용과 도메인을 분리하기도 하고 한 계층으로 합치기도 하지만 전체적인 아키텍처는 계층 구조를 따른다.
- 계층 구조는 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.

### 인프라스트럭처 계층에 종속

- 계층 구조를 엄격하게 적용한다면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위헤 계층 구조를 유연하게 적용하기도 한다.
- 즉, 응용 계층은 기본적으로 도메인 계층에 의존하지만, 편리하게 외부 시스템과의 연동을 위해 인프라스트럭처 계층에 의존하기도 한다는 말이다.
- 그러나 이러면 **인프라스트럭처 계층에 종속이 된다**는 문제점이 있다.
- 인프라스트럭처에 의존하면 다음과 같은 문제가 발생한다.
    - 테스트가 어려움
    - 기능 확장의 어려움

## 2.3 DIP

- 고수준 모듈은 의미 있는 단일 기능을 제공하는 모듈로 기능을 구현하려면 여러 하위 기능이 필요하다.
- 저수준 모듈은 하위 기능을 실제로 구현한 것이다.
- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데 고수준 모듈이 저수준 모듈을 사용하면 구현 변경과, 테스트가 어렵다는 문제가 발생한다.
- DIP는 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. 이는 **추상화한 인터페이스를 통해** 구현할 수 있다.
    - 이때 인터페이스 또한 고수준 모듈에 속하므로 인터페이스를 구현한 저수준 모듈이 고수준 모듈에 의존하게 된다. 이를 DIP(의존 역전 원칙)이라 부른다.
- DIP를 적용하면 구현 교체가 어렵다는 문제와 테스트가 어렵다는 문제를 해결할 수 있다.
    - 고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존하게 되므로 사용할 저수준 모듈을 변경해도 고수준 모듈을 수정할 필요가 없다.
    - 고수준 모듈이 저수준 모듈에 의존하지 않기 때문에 테스트 대역을 이용해 거의 모든 기능을 테스트 할 수 있다.

### DIP 주의사항

- DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다.

### DIP와 아키텍처

- 인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영역과 도메인 영역은 고수준 모듈이다.
- 인프라스트럭처 계층이 가장 하단에 위치하는 계층형 구조와 달리 아키텍처에 DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존하는 구조가 된다.
- 인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 인터페이스를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.

## 2.4 도메인 영역의 주요 구성요소

- 도메인 영역의 모델은 도메인의 주요 개념을 표현하며 핵심 로직을 구현한다.
- 도메인 영역을 구성하는 요소는 다음과 같다
    
    
    | 요소 | 설멍 |
    | --- | --- |
    | 엔티티 (Entity) | 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖고 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 데이터와 관련된 기능을 함께 제공한다. |
    | 밸류 (Value) | 고유의 식별자를 갖지 않는 객체로 주로 개념적인 하나의 값을 표현할 때 사용된다. 엔티티의 속성 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다. |
    | 애그리거트 (Aggregate) | 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. |
    | 리포지터리 (Repository) | 도메인 모델의 영속성을 처리한다. |
    | 도메인 서비스 (Domain Service) | 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다. |

### 엔티티와 밸류

- 도메인 모델의 엔티티와 DB 모델의 엔티티를 거의 같은 것으로 생각할 수 있으나, 실제로는 다르다.
- 두 모델의 가장 큰 차이점은 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 제공한다는 점이다.

```java
public class Order {
  // 주문 도메인 모델의 데이터
	private OrderNo number;
	private Orderer orderer;
	private ShippingInfo shippingInfo;
  ...
  
  // 도메인 모델 엔티티는 도메인 기능도 함께 제공
	public void changeShippingInfo(ShippingInfo newInfo) {

	}

}
```

- 도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객체이다.
- 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.
- 도메인 모델의 엔티티는 두 개 이성의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다.
    - RDBMS와 같은 관계현 데이터베이스는 밸류 타입을 제대로 표현하기 힘들다.

### 애그리거트

- 도메인이 커질수록 개발안 도메인 모델도 커지면서 많은 엔티티와 밸류가 출현한다. 엔티티와 밸류 개수가 많아질수록 모델은 점점 더 복잡해진다.
- 도메인 모델이 복잡해지면 개발자가 전체 구조가 아닌 한 개 엔티티와 밸류에만 집중하는 상황이 발생한다.
    - 이때 상위 수준에서 모델을 관리하지 않고 개별 요소에만 초점을 맞추다 보면, 큰 수준에서 모델을 이해하지 못해 큰 틀에서 모델을 관리할 수 없는 상황이 발생할 수 있다.
- 도메인 모델도 개별 객체뿐만 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는 데 도움이 된다. 도메인 모델에서 전체 구조를 이해하는 데 도움이 되는 것이 애그리커드이다.
- 애그리거트는 관련 객체를 하나로 묶은 군집이다.
    - EX) 도메인 개념이 주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액의 하위 모델로 구성될 때 이 하위 개념을 표현한 모델을 하나로 묶어 주문 이라는 상위 개념으로 표현할 수 있다.
- 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어 객체 군집 단위로 모델을 바라볼 수 있게 된다.
    - 개별 객체 간의 관계가 아닌 애그리거트 간의 관계로 도메인 모델을 이해하고 구현하게 되며, 이를 통해 큰 틀에서 도메인 모델을 관리할 수 있다.
- 애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다. 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
- 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근한다.
- 애그리거트를 구현할 때는 고려할 것이 많다. 애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고, 트랜잭션 범위가 달라지기도 한다. 또한 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 한다.

### 리포지터리

- 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델이다.
- 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
- 도메인 모델을 사용해야 하는 코드는 리포지터리를 통해서 도메인 객체를 구한 뒤에 도메인 객체의 기능을 실행한다.
- 도메인 모델 관점에서 리포지터리(인터페이스)는 도메인 객체를 영속화하는 데 필요한 기능을 추상화한 것으로 고수준 모듈에 속한다.
    - 이를 구현한 클래스는 저수준 모듈로 인프라스트럭처 영역에 속한다.

## 2.5 요청 처리 흐름

- 사용자가 애플리케이션에 가능 실행을 욧청한다.
- 표현 영역에서 해당 요청을 받아 처리한다.
- 표현 영역은 사용자가 전송한 데이터 형식이 올바른지 검사하고 문제가 없다면 데이터를 이용해서 응용 서비스에 기능 실행을 위임한다.
    - 이때 표현 영역은 사용자가 전송한 데이터를 응용 서비스가 요구하는 형식으로 반환해서 전달한다.
- 응용 서비스는 도메인 모델을 이용해서 기능을 구현한다.
    - 기능 구현에 필요한 도메인 객체를 리포지터리에서 가져와 실행하거나 신규 도메인 객체를 생성해서 리포지터리에 저장한다.
- 이후 응용 서비스는 결과를 표현 계층에 리턴하고 표현 계층은 이를 다시 사용자에게 리턴한다.

## 2.6 인프라스트럭처 개요

- 인프라스트럭처는 표현, 응용, 도메인 영역을 지원한다.
    - 도메인 객체의 영속성 처리, 트랜잭션, SMTP 클라이언드, REST 클라이언트 등 다른 영역에서 필요로 하는 프레임워크, 구현 기술, 보조 기능을 지원한다.
- DIP를 사용하면 인프라스트럭처 영역에 대한 의존을 없애고 시스템을 더 유연하고 테스트하기 쉽게 만들 수 있다.
- 하지만 무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없다. EX) `@Transactional`
    - **구현의 편리함은 DIP가 주는 장점만큼 중요하기에** DIP의 장점을 해치지 않는 범위에서 구현 기술에 대한 의존을 가져가는 것이 나쁘지 않다고 생각한다.

## 2.7 모듈 구성

- 아키텍처 각 영역은 별도 패키지에 위치한다.
- 도메인이 크면 도메인마다 별도 패키지를 구성할 수 있다.
    - 응용 서비스 또한 도메인 별로 패키지를 구분할 수 있다.
- 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다.
- 애그리거트, 모델, 리포지터리는 같은 패키지에 위치시킨다.
- 도메인이 복잡하면 도메인 모델과 도메인 서비스를 벼로 패키지에 위치시킬 수도 있다.
- 모듈 구조를 얼마나 세분화해야 하는지에 대해 정해진 규칙은 없다.
    - 한 패키지에 너무 많은 타입이 몰려 코드를 찾을 때 불편한 정도만 아니면 된다.