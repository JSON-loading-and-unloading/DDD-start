# 08 애그리거트 트랜잭션 관리

## 8.1 애그리거트와 트랜잭션

- 트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성하므로 각 스레드는 같은 애그리거트를 나타내는 다른 객체를 구하게 된다.
- 각 스레드는 개념적으로 동일한 애그리거트지만 물리적으로 서로 다른 애그리거트 객체를 사용한다. 때문에 한 스레드에서 애그리거트 객체의 상태를 변경하더라도 다른 스레드가 사용하는 애그리거트 객체에는 영향을 주지 않는다.
    - 각 스레드는 각각 트랜잭션을 커밋할 때 수정한 내용을 db에 반영한다. 따라서 동시에 커밋하는 경우 애그리거트의 일관성이 깨질 수 있다.
    - DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다.
    - 애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금의 두 가지 방식이 있다.

## 8.2 선점 잠금

- 선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.
- 스레드1이 선점 잠금 방식으로 애그리거트를 구한 뒤 이어서 스레드2가 같은 애그리거트를 구하려는 경우, 스레드2는 스레드1이 애그리거트에 대한 잠금을 해제할 때까지 블로킹 된다.
- 스레드1이 애그리거트를 수정하고 트랜잭션을 커밋하면 잠금을 해제한다. 이 순간 대기하고 있던 스레드2가 애그리거트에 접근하게 된다.
- 스레드1이 트랜잭션을 커밋한 뒤에 스레드2가 애그리거트를 구하게 되므로 스레드2는 스레드1이 수정한 애그리거트의 내용을 보게 된다.
- 한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다.
- 선점 잠금은 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현한다. 오라클을 비롯한 다수의 DBMS가 for update와 같은 쿼리를 사용해 특정 레코드에 한 커넥션만 접근할 수 있는 잠금장치를 제공한다.

### 8.2.1 선점 잠금과 교착 상태

- 선점 잠금 기능을 사용할 때는 잠금 순서에 따라 교착 상태가 발생하지 않도록 주의해야 한다.

```
스레드1: A 애그리거트에 대한 선점 잠금 구함
스레드2: B 애그리거트에 대한 선점 잠금 구함
스레드1: B 애그리거트에 대한 선점 잠금 시도
스레드2: A 애그리거트에 대한 선점 잠금 시도
```

- 이 순서에 따르면 스레드 1은 영원히 B애그리거트에 대한 선점 잠금을 구할 수 없다.
- 동일하게 스레드2는 A애그리거트에 대한 잠금을 구할 수 없다.
    - 이를 교착상태라고 한다.
- 선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드는 더 빠르게 증가한다.
- 이런 문제가 발생하지 않도록 하려면 잠금을 구할 때 최대 대기 시간을 지정해야 한다.

## 8.3 비선점 잠금

- 선점 잠금이 강력해 보이긴 하지만 선점 잠금으로 모든 트랜잭션 충돌 문제가 해결되는 것은 아니다.

```
1. 운영자는 배송을 위해 주문 정보를 조회한다. 시스템은 정보를 제공한다.
2. 고객이 배송지 변경을 위해 변경 폼을 요청한다. 시스템은 변경 폼을 제공한다.
3. 고객이 새로운 배송지를 입력하고 폼을 전송하여 배송지를 변경한다.
4. 운영자가 1번에서 조회한 주문 정보를 기준으로 배송지를 정하고 배송 상태 변경을 요청한다.
```

- 위 시나리오에서 문제는 운영자가 배송지 정보를 조회하고 배송 상태로 변경하는 사이에 고객이 배송지를 변경한다는 것이다.
- 운영자는 고객이 변경하기 전 배송지 정보를 이용하여 배송 준비를 한 뒤에 배송 상태로 변경하게 된다.
    - 즉, 배송 상태 변경 전에 배송지를 한번 더 확인하지 않으면 운영자는 다른 배송지로 물건을 발송하게 되고, 고객은 배송지를 변경했음에도 불구하고 엉뚱한 곳으로 주문한 물건을 받는 상황이 발생하게 된다.
    - 이 문제는 선점 잠금 방식으로는 해결할 수 없고, 이때 필요한 것이 비선점 잠금이다.
- 비선점 잠금은 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.
- 비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 한다. 애그리거트를 수정할 때마다 버전으로 사용할 프로퍼티 값이 1씩 증가하게끔 구현해야 한다.
    - 수정할 애그리거트와 매핑되는 테이블의 버전 값이 현재 애그리거트의 버전과 동일한 경우에만 데이터를 수정한다. 그리고 수정에 성공하면 버전 값을 1 증가시킨다. 다른 트랙잭션이 먼저 데이터를 수정해서 버전 값이 바뀌면 데이터 수정에 실패하게 된다.
- 응용 서비스는 버전에 대해 알 필요가 없다. 리포지터리에서 필요한 애그리거트를 구하고 알맞은 기능만 실행하면 된다.
- 기능 실행 과정에서 애그리거트 데이터가 변경되면 JPA는 트랜잭션 종료 시점에 비선점 잠금을 위한 쿼리를 실행한다.
- 비선점 잠금 방식을 여러 트랜잭션으로 확장하려면 애그리거트 정보를 뷰로 보여줄 때 버전 정보도 함께 사용자 화면에 전달해야 한다.

### 8.3.1 강제 버전 증가

- 애그리거트에 애그리거트 루트 외에 다른 엔티티가 존재하는데 기능 실행 도중 루트가 아닌 다른 엔티티의 값만 변경될 경우 JPA는 루트 엔티티의 버전 값을 증가시키지 않는다.
    - 연관된 엔티티의 값이 변경된다고 해도 루트 엔티티 자체의 값은 바뀌는 것이 없으므로 루트 엔티티의 버전 값은 갱신하지 않는 것이다.
- 이런 JPA 특징은 애그리거트 관점에서 보면 문제가 된다. 비록 루트 엔티티의 값이 바뀌지 않았더라도 애그리거트의 구성요소 중 일부 값이 바뀌면 논리적으로 그 애그리거트는 바뀐 것이다. 따라서 애그리거트 내에 어떤 구성요소의 상태가 바뀌면 루트 애그리거트의 버전 값이 증가해야 비선점 잠금이 올바르게 동작한다.
- 따라서 강제로 버전 값을 증가 시키는 잠금모드를 사용해 애그리거트 루트 엔티티가 아닌 다른 엔티티나 밸류가 변경되더라도 버전 값을 증가시킬 수 있으므로 비선점 잠금 기능을 안전하게 적용할 수 있다.

## 8.4 오프라인 선점 잠금

- 단일 트랜잭션에서 동시 변경을 막는 선점 잠금 방식과 달리 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.
- 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해체한다. 잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다.
- 만약 두 개의 트랜잭션으로 구성된 기능에서 사용자가 첫 번째 트랜잭션까지만 수행하고 서비스를 나가버리는 경우, 잠금을 해제하지 않으므로 다른 사용자는 영원히 잠금을 구할 수 없는 상황이 발생라므로 유효 시간이 지나면 자동으로 잠금을 해제해서 다른 사용자가 잠금을 일정 시간 후에 다시 구할 수 있도록 해야 한다.

### 8.4.1 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스

- 오프라인 선점 잠금은 크게 잠금 선점 시도, 잠금 확인, 잠금 해제, 잠금 유효시간 연장의 네 가지 기능이 필요하다.
- LockManager 인터페이스는 다음과 같다.

```java
public interface LockManager {
	LockId tryLock(String type, String id) throws LockException;
	
	void checkLock(LockId lockId) throws LockException;
	
	void releaseLock(LockId lockId) throws LockException;
	
	void extendLockExpiration(LockId, lockId, long inc) throws LockException;	
}
```

- tryLock()메서드는 type와 id 파라미터로 갖는다. 이 두 파라미터에는 각각 잠글 대상 타입과 식별자를 값으로 전달하면 된다. tryLock()은 잠금을 식별할 때 사용할 LockId를 리턴한다.
- 오프라인 선점 잠금이 필요한 코드는 LockManager#tryLock()을 이용해서 잠금을 시도한다. 잠금에 성공하면 tryLock()은 LockId를 리턴한다. 이 LockId는 다음에 잠금을 해제할 때 사용한다. LockId가 없으면 잠금을 해제할 수 없으므로 LockId를 어딘가에 보관해야 한다.

### 8.4.2 DB를 이용한 LockManager 구현

- DB에서는 잠금 정보를 저장할 테이블과 인덱스를 생성한다.
- 한 애그리거트에 대한 잠금을 구하고 싶다면 잠금 정보 저장 테이블에 데이터를 삽입하면 된다.
- type과 id 칼럼을 주요키로 지정해서 동시에 두 사용자가 특정 타입 데이터에 대한 잠금을 구하는 것을 방지하고, 각 잠금마다 새로운 LockId를 사용하므로 lockid 필드를 유니크 인덱스로 설정, 잠금 유효 시간을 보관하기 위해 expiration_time 칼럼을 사용한다.