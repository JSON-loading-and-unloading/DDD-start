# 8장 애그리거트 트랜잭션 관리

## 8.1 애그리거트와 트랜잭션

* 애그리거트에서 일관성이 깨지는 경우를 방지하고자 다음과 같은 방법을 사용합니다.
  * 애그리거트를 수정중이면 다른 클라이언트가 해당 정보를 수정하지 못하게함
  * 애그리거트를 수정하는 동안 다른 클라이언트가 해당 애그리거트를 다시 조회하게함
* 이를 트랜잭션에서 낙관적, 비관적 락을 통해서 처리할 수 있습니다.

## 8.2 선점 잠금(비관적 락)

* 선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트를 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.
* jpa에서 `@Lock(LockModeType.PESSIMISTIC_WRITE)`를 사용하면 선점 잠금을 사용할 수 있다.
* 선점 잠금을 사용할 때 데드락이 발생하지 않도록 조심해야 합니다. 이를 jpa에서는 타임아웃을 지정해서 잠금을 구하는 최대 대기 시간을 지정해야 한다.

## 8.3 비선점 잠금(낙관적 락)

* 비전섬 잠금은 동시에 접근하는 것을 막지 않고 데이터베이스에 반영할 때 반영 가능한지 확인합니다.
* JPA에서는 `@Version`을 사용해 해당 데이터의 버전을 관리하며 이를 통해 낙관적 락을 사용할 수 있습니다. 또한 스핀락과 함께 사용하여 처리가 정상적으로 완료되도록할 수 있습니다.
* JPA에서 루트 엔티티는 변경되지 않고, 연관된 엔티티의 값만 변경되면 루트 엔티티의 버전 정보는 변경되지 않는다. 하지만 이는 논리적으로 봤을 때 애그리거트가 변경된 것이라고 볼 수 있기 때문에 버전을 증가시켜야 한다.
* JPA에서 LockModeType.OPTIMISTIC_FORCE_INCREMENT를 사용하면 버전을 강제로 증가시킬 수 있다.

## 8.4 오프라인 선점 잠금

* 오프라인 선점 잠금은 애그리거트를 수정할 때 다른 클라이언트가 해당 애그리거트를 수정하지 못하게 하는 방식이다.
* 이는 잠금을 해제하지 않는 경우 다른 클라이언트가 영원히 수정하지 못할 수 있기 때문에 잠금 점유 시간을 설정해야 한다.
* 오프라인 락은 클라이언트한테 락에 관한 정보를 넘겨주며 해당 정보를 통해 락을 해제할 수 있도록한다.
* 오프라인 락은 데이터베이스를 통해서도 관리할 수 있다.